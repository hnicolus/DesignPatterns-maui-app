[
	{
		"id": 1,
		"name": "Singleton Pattern",
		"description": "The singleton pattern is a software design pattern that restricts the instantiation of a class to one \"single\" instance. This is useful when exactly one object is needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton",
		"purpose": "To ensure an object has only a single instance",

		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/Singleton_UML_class_diagram.svg/1920px-Singleton_UML_class_diagram.svg.png"
		],
		"categoryId": 1,
		"icon": "singleton.png"
	},
	{
		"id": 2,
		"name": "Factory Method",
		"purpose": "",
		"description": "The factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.",
		"images": [
			"https://www.oreilly.com/library/view/design-patterns-and/9781786463593/assets/7b9b05d9-b441-4fa4-a6f4-05bbda05524a.png"
		],
		"categoryId": 1,
		"icon": "factory.png"
	},
	{
		"id": 3,
		"name": "Abstract Factory Pattern",
		"purpose": "",
		"description": "The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme. The client does not know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface.",
		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Abstract_factory.svg/1920px-Abstract_factory.svg.png"
		],
		"categoryId": 1,
		"icon": "abstractfactory.png"
	},
	{
		"id": 4,
		"name": "Prototype Pattern",
		"purpose": "",
		"description": "The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.",
		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Prototype_UML.svg/1920px-Prototype_UML.svg.png"
		],
		"categoryId": 1,
		"icon": "prototype.png"
	},
	{
		"id": 5,
		"name": "Builder Pattern",
		"purpose": "",
		"description": "The builder pattern is a design pattern designed to provide a flexible solution to various object creation problems in object-oriented programming. The intent of the Builder design pattern is to separate the construction of a complex object from its representation. It is one of the Gang of Four design patterns.",
		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Builder_UML_class_diagram.svg/800px-Builder_UML_class_diagram.svg.png"
		],
		"categoryId": 1,
		"icon": "builder.png"
	},
	{
		"id": 6,
		"name": "Strategy Pattern",
		"purpose": "",
		"description": "the strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.",
		"images": [""],
		"categoryId": 3,
		"icon": "abstractFactory.png"
	},
	{
		"id": 7,
		"name": "State Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "state.png"
	},
	{
		"id": 8,
		"name": "Memento Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "memento.png"
	},
	{
		"id": 9,
		"name": "Iterator Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "tool.png"
	},
	{
		"id": 10,
		"name": "Chain of Responsibility",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "chain.png"
	},
	{
		"id": 12,
		"name": "Observer Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "observer.png"
	},
	{
		"id": 13,
		"name": "Visitor Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "visitor.png"
	},
	{
		"id": 22,
		"name": "Mediator Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "mediator.png"
	},
	{
		"id": 23,
		"name": "Command Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 3,
		"icon": "tool.png"
	},
	{
		"id": 15,
		"name": "Adaptor Pattern",
		"purpose": "",
		"description": "The adapter pattern is a pattern that allows the interface of an existing class to be used as another interface.An adapter allows two incompatible interfaces to work together. This is the real-world definition for an adapter. Interfaces may be incompatible, but the inner functionality should suit the need. The adapter design pattern allows otherwise incompatible classes to work together by converting the interface of one class into an interface expected by the clients. ",
		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/d/d7/ObjectAdapter.png"
		],
		"categoryId": 2,
		"icon": "adapter.png"
	},
	{
		"id": 16,
		"name": "Decorator Pattern",
		"purpose": "",
		"description": "The adapter pattern is a pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class.The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.Decorator use can be more efficient than subclassing, because an object's behavior can be augmented without defining an entirely new object.",
		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Decorator_UML_class_diagram.svg/1280px-Decorator_UML_class_diagram.svg.png"
		],
		"categoryId": 2,
		"icon": "decorator.png"
	},
	{
		"id": 17,
		"name": "Faćade Pattern",
		"purpose": "",
		"description": "The facade pattern is a design pattern commonly used in object-oriented programming.Developers often use the facade design pattern when a system is very complex or difficult to understand because the system has many interdependent classes or because its source code is unavailable. This pattern hides the complexities of the larger system and provides a simpler interface to the client. It typically involves a single wrapper class that contains a set of members required by the client. These members access the system on behalf of the facade client and hide the implementation details.The facade is an object that serves as a front-facing interface masking more complex underlying or structural code.It improves the readability and usability of modules by masking interaction with more complex components behind a single simple API.It serve as a starting point for a broader refactor of monolithic or tightly-coupled systems in favor of more loosely-coupled code",
		"images": [
			"https://upload.wikimedia.org/wikipedia/en/5/57/Example_of_Facade_design_pattern_in_UML.png"
		],
		"categoryId": 2,
		"icon": "facade.png"
	},
	{
		"id": 18,
		"name": "Proxy Pattern",
		"purpose": "",
		"description": "The proxy pattern is a software design pattern that in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy, extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. For the client, usage of a proxy object is similar to using the real object, because both implement the same interface. ",
		"images": [
			"https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/1920px-Proxy_pattern_diagram.svg.png"
		],
		"categoryId": 2,
		"icon": "proxy.png"
	},
	{
		"id": 19,
		"name": "Flyweight Pattern",
		"purpose": "",
		"description": "The flyweight software design pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.",
		"images": ["https://static.dzone.com/dz1/dz-files/flyweight_pattern.png"],
		"categoryId": 2,
		"icon": "flyweight.png"
	},
	{
		"id": 20,
		"name": "Bridge Pattern",
		"purpose": "",
		"description": "",
		"images": [""],
		"categoryId": 2,
		"icon": "bridge.png"
	}
]
